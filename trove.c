//  CITS2002 Project 2 2022
//  Student1:   22441767   KING   MICHAEL   100

#include "trove.h" //local header file provides declarations

#define OPTLIST "bf:l:ru"

void usage()
{
  printf("Usage: ./trove [-f filename] [-b | -r | -u] [-l length] filelist\n");
  printf("or     ./trove [-f filename] word\n");
  printf("\nwhere options are:\n");
  printf("  -b		build a new trove-file\n");
  printf("  -f filename	provide the name of the trove-file to be built or searched\n");
  printf("  -l length	specify the minimum-length of words added to the trove-file\n");
  printf("  -r		remove information from the trove-file\n");
  printf("  -u		update information in the trove-file\n");
  printf("\nPlease report any bugs to 22441767@student.uwa.edu.au\n");
  exit(EXIT_FAILURE);
  /* NOTREACHED */
}

int main(int argc, char *argv[])
{
  int opt;
  bool bflag = false;
  bool rflag = false;
  bool uflag = false;
  bool lflag = false;
  bool wordflag = false;
  bool filenameflag = false;
  char *word = NULL;

  int optionCount = 0; // Tracks how many options are used to determine where filelist/word starts.

  opterr = 0;
  while ((opt = getopt(argc, argv, OPTLIST)) != -1)
  {
    if (opt == 'b')
    {
      optionCount++;
      bflag = !bflag;
      printf("we have a -b\n");
    }
    else if (opt == 'f')
    {
      optionCount = optionCount + 2;
      filenm = strdup(optarg);
      printf("we have a -f with filename %s\n", filenm);
    }
    else if (opt == 'l')
    {
      optionCount = optionCount + 2;
      lflag = !lflag;
      wordlgth = atoi(optarg);
      printf("we have a -l with value %i\n", wordlgth);
      if (wordlgth <= 0)
      {
        printf("-l value cannot be less than 0!\n");
        exit(EXIT_FAILURE);
      }
    }
    else if (opt == 'r')
    {
      optionCount++;
      rflag = !rflag;
      printf("we have a -r\n");
    }
    else if (opt == 'u')
    {
      optionCount++;
      uflag = !uflag;
      printf("we have a -u\n");
    }
    else
    {
      argc = -1;
    }
  }
  printf("filename is: %s, word length is: %i, argc is: %i and optionCount is: %i\n", filenm, wordlgth, argc, optionCount);

  if (argc <= 0)
  { //  display program's usage/help
    usage();
  }
  else if (argc == optionCount + 1) // tests if no word or filelist has been given.
  {
    usage();
  }

  // Test if args at end are word or filename
  if (bflag == false && lflag == false && uflag == false && rflag == false)
  {
    wordflag = true;
  }
  else
  {
    filenameflag = true;
  }

  int fileNum = argc - optionCount - 1;
  char *filelist[fileNum];

  // Executes code for the prompt 1.
  if (wordflag == true)
  {
    word = (char *)malloc(strlen(argv[optionCount + 1]) + 1);
    strcpy(word, argv[optionCount + 1]);
    // Stores the word in a variable
    for (int i = optionCount + 2; i < argc; i++)
    {
      word = (char *)realloc(word, strlen(argv[i]) + 1);
      strcat(word, " ");
      strcat(word, argv[i]);
    }
    printf("word is: %s\n", word);
    // Uses hashtable to find paths attached the word.
    find_word(word);
  }

  // Executes code for the prompt 2.
  if (filenameflag == true) // enters if making/modifying trove
  {
    // Generates an array containing our files/directories.
    for (int j = 0; j < fileNum; j++)
    {
      filelist[j] = argv[1 + optionCount + j];
    }
    if (bflag == true) // builds a trove-file!
    {
      // Replaces the file if it exist with an empty one.
      if (access(filenm, F_OK) == 0)
      {
        FILE *trovew = fopen(filenm, "w");
        fclose(trovew);
      }
      // Generates file containing the words.
      print_path(filelist, fileNum);
      // Compresses the file.
      compress(filenm);
    }
    else if (rflag == true) // Removes elements from the trove file.
    {
      printf("Removing files...\n");
      remove_files(filelist, fileNum, uflag);
    }
    else if (uflag == true) // Updates files by using remove to get rid of crossover files, then appends that removed file to the end of the file generated by the filelist.
    {
      store_paths(filelist, fileNum); // Stores path as they are found from the filelist.
      printf("Absolute path files to be updated are:\n");
      char *updatepathspter[updpathsnum];
      for (int j = 0; j < updpathsnum; j++)
      {
        updatepathspter[j] = updatepaths[j]; // updatepaths is a global array containing all our paths
      }
      for (int j = 0; j < updpathsnum; j++)
      {
        printf("%s\n", updatepathspter[j]);
      }
      printf("Updating files...\n");

      char *prevfilenm = filenm;
      filenm = updatefile;
      print_path(updatepathspter, updpathsnum); // Generates trove for the filelist given with -u command.
      filenm = prevfilenm;
      remove_files(updatepathspter, updpathsnum, uflag); // Appends the updated file list to the end of the trove file that has had all crossover paths removed.
    }
  }

  argc -= optind;
  argv += optind;
  return 0;
}
